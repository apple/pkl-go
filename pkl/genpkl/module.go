// ===----------------------------------------------------------------------===//
// Copyright Â© 2024 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ===----------------------------------------------------------------------===//
package genpkl

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"unicode"
)

type Module struct {
	HasMembers
	Name    string
	model   *Model
	classes map[string]*Class
}

func NewModule(m *Model, name string) *Module {
	return &Module{
		HasMembers: HasMembers{members: map[string]*Member{}},
		Name:       name,
		model:      m,
	}
}

func (m *Module) SavePkl(path string) error {
	text := m.PklString()
	err := os.WriteFile(path, []byte(text), DefaultFileWritePermissions)
	if err != nil {
		return fmt.Errorf("failed to save pkl file %s: %w", path, err)
	}
	return nil
}

func (m *Module) PklString() string {
	buf := &strings.Builder{}
	buf.WriteString(fmt.Sprintf("/// %s\n", m.Name))
	buf.WriteString("///\n")
	buf.WriteString("/// NOTE: this file is autogenerated by go genpkl\n")
	buf.WriteString(fmt.Sprintf("module %s\n\n", m.Name))

	m.HasMembers.WritePkl(buf, "")
	buf.WriteString("\n")

	m.lock.Lock()
	defer m.lock.Unlock()

	for _, clazz := range m.classes {
		clazz.WritePkl(buf, "")
	}

	return buf.String()
}

func (m *Module) GetClass(name string, create bool) *Class {
	m.lock.Lock()
	defer m.lock.Unlock()

	if m.classes == nil {
		m.classes = map[string]*Class{}
	}
	answer := m.classes[name]
	if answer == nil && create {
		answer = NewClass(m.model, name)
		m.classes[name] = answer
	}
	return answer
}

func (m *Module) GetOrCreateClass(typeName string, t reflect.Type) *Class {
	// strip trailing?
	for {
		if !strings.HasSuffix(typeName, "?") {
			break
		}
		typeName = typeName[0 : len(typeName)-1]
	}

	// if we have a module already then ignore
	if m.model.GetModule(typeName, false) != nil {
		return nil
	}

	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	if t.Kind() != reflect.Struct {
		return nil
	}

	clazz := m.GetClass(typeName, true)

	numFields := t.NumField()
	for i := 0; i < numFields; i++ {
		field := t.Field(i)

		generator := m.model.generator
		ft := field.Type
		fieldTypeName := generator.typeName(ft)

		if field.Anonymous {
			if clazz.Extends != "" {
				fmt.Printf("only a single anonymous struct field is supported")
				continue
			}
			clazz.Extends = fieldTypeName
			if base := m.GetOrCreateClass(fieldTypeName, ft); base != nil {
				base.Abstract = true
			}
		} else {
			// ignore lower case fields
			firstChar := []rune(field.Name)[0]
			if !unicode.IsUpper(firstChar) {
				continue
			}
			name := generator.getFieldName(&field)
			clazz.GetOrCreateField(name, fieldTypeName, field)
			m.GetOrCreateClass(fieldTypeName, ft)
		}
	}
	return clazz
}
